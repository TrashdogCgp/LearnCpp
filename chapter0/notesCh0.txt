0.1
Not much to say here.
Instructors advise typing the examples rather than copying and pasting. This was the plan anyway.

0.2
Languages- binary, assembly, high-level.
We know this.
Assembly languages are translated into machine language before execution by a computer-- this is done by a program called an assembler.
Assembly language is still not really that human-readable, and also definitely not portable because different hardware will use different instruction sets.
For high-level languages, compilers are programs that read source code and produce a standalone executable program that can be run; this executable does not require the compiler once it's created.
An interpreter directly executes the instructions in source code without requiring compilation. interpreters are less efficient, but more flexible than compilers. The interpreter also is needed every time the program is run.
While most languages can be compiled or interpreted, C++ is compiled... strictly so? I think? I haven't heard of any weird exception, but not much surprises me anymore........
There is some platform-specific code in high-level languages, and C++ is no exception. But these tutorials will avoid that.

0.3
C++ is thought of as a superset of C, although C99 introduced a few features absent in C++.
C++ differs in that it's object-oriented.
Five major updates have been made since 2003:
C++11, C++14, C++17, C++20, and C++23, each adding additional functionality. C++11 was the biggest deal of them, though, and is considered the de facto baseline for modern C++.

0.4
Intro to C++ Development is an easy topic to scoff at, but I've promised to take this whole site seriously and commit to extensive coverage.
So...
Define problem
Determine how to solve it (good solutions are: straightforward, well documented, built modularly, and robust--can recover or give useful error messages when unexpected things happen)
Determining a solution is the most neglected step in swdev, because 80% of dev time is spent maintaining rather than writing programs.
Write the program--step requires programming language knowledge and text editor.
Be picky with text editors! And also note that because source code is written with ASCII characters (throw UTF8 emoji nonsense into Mount Doom, please and thank you!), not-equals can't just be an equals with a strikethrough. Note that ascii 'art', if you can call it that, represents mathematical concepts normally represented by symbols.
Also note that while programs are usually named *.cpp, some programs use the extension .cc or .cxx instead.
The tutorial recommends using .cpp for code files.

0.5
Step 3 in the previous lesson was writing the code. Here, we pick up with step 4: compiling source code
Compiler
Compiler goes through each .cpp file and does two important things:
Checks code to make sure it follows C++ rules (error from compiler if it doesn't, and process aborts)
Translates C++ source code into an object file (machine language)
Linker
After the compiler creates one or more object files, another program called the linker does three things:
First, take all object files generated by the compiler and combine them into a single executable
Second, the linker can link library files in addition to object files. A library file is a collection of precompiled code that has been "packaged" for reuse in other programs. 
Note: I really can't stand this whole "packaged" analogy and it bothers me quite a lot that comp sci frequently uses terms that, when you think about it, have pretty nebulous meanings.
C++ comes with the standard library, and one of the most commonly used parts is the iostream library, which has functionality for printing text on a monitor and getting keyboard input from a user.
Third, the linker makes sure all cross-file dependencies are resolved properly, e.g. a definition in one cpp file can be used in another cpp file, and in this case the linker connects the two. Linker errors happen if the linker can't connect a reference with its definition.
Once the linker is done, you have an executable file that you can run.

For complex projects, build automation tools (make or build2 being examples) are often used to help automate building programs and running automated tests. They're not part of C++ core, and they're not needed in these tutorials.

Steps 6 & 7 are testing and debugging.
More on this later, within the context of the tutorial.

0.6
Installing an IDE (software to make developing, building, and debugging programs easier)
Typical features include:
Ways to load/save code files
Code editor with programming-friendly features, such as line numbering, syntax highlighting, integrated help, name completion, and automatic source code formatting
A basic build system to compile/link/execute programs
An integrated debugger to make it easier to find/fix software defects
Some way to install plugins so you can modify the IDE or add capabilities like version control

Choosing an IDE?
Well, I chose VSCode for more reasons than I care to cover.
Tutorial recommends at least GCC/g++7 to ensure C++17 support. My version of g++ is 12.1.0, and 12 is greater than 7, so I think we're good.
Still worth noting, just don't use a compiler that doesn't at least support C++11, the modern baseline for C++.
[despite my commitment to going through this in depth, no notes on Visual Studio or CodeBlocks]
Tutorial gives a shoutout to Xcode, but a friend does nothing but complain about Xcode, so thankfully they're not going to push it... and also I don't plan to get a Mac unless encouraged at gunpoint.

0.7
Compiling your first program
Hilarious title. But they say we usually start by creating a new project. A project is a container that holds all of your source code files, images, data files, etc, that are needed to produce an executable/library. Projects also save various IDE, compiler, and linker settings, and remembers where you left off.
Each project corresponds to one program. When you're ready to create a second program, you need a new project, or can overwrite a project if you don't want to keep it. Project files are generally IDE-specific.

Console projects are all we'll do in these tutorials.

Many IDEs will automatically add projects to a workspace or solution, with the term varying by IDE. This is a container that can hold one or more projects.
This tutorial nonetheless recommends a separate solution or workspace for each program, especially while learning.

While going over the Hello World program, the tutorial mentions precompiled headers.
These can improve compilation speed by avoiding some redundant compilation that tends to occur in larger projects. However, these also require extra work to use, and make no difference to smaller projects like these tutorials.

In my case, helloThere.cpp is included just to say I adhered to the tutorials like I know I should. However, rather than following IDE steps, ctrl shift B in VSCode will build without running to mimic their steps.

And funnily enough, they give a VS Code section after I already assumed they were focusing on Visual Studio. Dang.
They basically said to open a folder (which I'd already done) and create hello world, but they also... seemed to indicate that this folder was a project.
What goes on behind the scenes to make anything that could be considered a project file? Some VSCode wizard could really help me here...

Also, differences between compile, build, rebuild, clean, and run/start in IDE:
Build compiles all modified code files in the project, then links the object files into an executable. If no code files have been modified since the last build, this option does nothing.
Clean removes all cached objects and executables so the next time the project builds, all files will be recompiled and a new exe is produced.
Rebuild does clean, then build.
Compile recompiles a single code file. This option doesn't invoke the linker or produce an exe.
Run/start executes the executable from a prior build. Some IDEs (VS, for example) will invoke a build before doing a run to avoid missing the latest version's behavior.

0.8
Common problems
Reading this section, but after a quick skim, probably not taking notes when I re-read in depth.
Scratch that!
The C++ standard requires that all cpp source files end in a newline.

0.9
Configuring compiler: Build configurations





