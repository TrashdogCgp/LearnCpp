0.1
Not much to say here.
Instructors advise typing the examples rather than copying and pasting. This was the plan anyway.

0.2
Languages- binary, assembly, high-level.
We know this.
Assembly languages are translated into machine language before execution by a computer-- this is done by a program called an assembler.
Assembly language is still not really that human-readable, and also definitely not portable because different hardware will use different instruction sets.
For high-level languages, compilers are programs that read source code and produce a standalone executable program that can be run; this executable does not require the compiler once it's created.
An interpreter directly executes the instructions in source code without requiring compilation. interpreters are less efficient, but more flexible than compilers. The interpreter also is needed every time the program is run.
While most languages can be compiled or interpreted, C++ is compiled... strictly so? I think? I haven't heard of any weird exception, but not much surprises me anymore........
There is some platform-specific code in high-level languages, and C++ is no exception. But these tutorials will avoid that.

0.3
C++ is thought of as a superset of C, although C99 introduced a few features absent in C++.
C++ differs in that it's object-oriented.
Five major updates have been made since 2003:
C++11, C++14, C++17, C++20, and C++23, each adding additional functionality. C++11 was the biggest deal of them, though, and is considered the de facto baseline for modern C++.

0.4
Intro to C++ Development is an easy topic to scoff at, but I've promised to take this whole site seriously and commit to extensive coverage.
So...
Define problem
Determine how to solve it (good solutions are: straightforward, well documented, built modularly, and robust--can recover or give useful error messages when unexpected things happen)
Determining a solution is the most neglected step in swdev, because 80% of dev time is spent maintaining rather than writing programs.
Write the program--step requires programming language knowledge and text editor.
Be picky with text editors! And also note that because source code is written with ASCII characters (throw UTF8 emoji nonsense into Mount Doom, please and thank you!), not-equals can't just be an equals with a strikethrough. Note that ascii 'art', if you can call it that, represents mathematical concepts normally represented by symbols.
Also note that while programs are usually named *.cpp, some programs use the extension .cc or .cxx instead.
The tutorial recommends using .cpp for code files.

0.5
Step 3 in the previous lesson was writing the code. Here, we pick up with step 4: compiling source code
Compiler
Compiler goes through each .cpp file and does two important things:
Checks code to make sure it follows C++ rules (error from compiler if it doesn't, and process aborts)
Translates C++ source code into an object file (machine language)
Linker
After the compiler creates one or more object files, another program called the linker does three things:
First, take all object files generated by the compiler and combine them into a single executable
Second, the linker can link library files in addition to object files. A library file is a collection of precompiled code that has been "packaged" for reuse in other programs. 
Note: I really can't stand this whole "packaged" analogy and it bothers me quite a lot that comp sci frequently uses terms that, when you think about it, have pretty nebulous meanings.
C++ comes with the standard library, and one of the most commonly used parts is the iostream library, which has functionality for printing text on a monitor and getting keyboard input from a user.
Third, the linker makes sure all cross-file dependencies are resolved properly, e.g. a definition in one cpp file can be used in another cpp file, and in this case the linker connects the two. Linker errors happen if the linker can't connect a reference with its definition.
Once the linker is done, you have an executable file that you can run.

For complex projects, build automation tools (make or build2 being examples) are often used to help automate building programs and running automated tests. They're not part of C++ core, and they're not needed in these tutorials.

Steps 6 & 7 are testing and debugging.
More on this later, within the context of the tutorial.

0.6
Installing an IDE (software to make developing, building, and debugging programs easier)
Typical features include:
Ways to load/save code files
Code editor with programming-friendly features, such as line numbering, syntax highlighting, integrated help, name completion, and automatic source code formatting
A basic build system to compile/link/execute programs
An integrated debugger to make it easier to find/fix software defects
Some way to install plugins so you can modify the IDE or add capabilities like version control

Choosing an IDE?
Well, I chose VSCode for more reasons than I care to cover.
Tutorial recommends at least GCC/g++7 to ensure C++17 support. My version of g++ is 12.1.0, and 12 is greater than 7, so I think we're good.
Still worth noting, just don't use a compiler that doesn't at least support C++11, the modern baseline for C++.
[despite my commitment to going through this in depth, no notes on Visual Studio or CodeBlocks]
Tutorial gives a shoutout to Xcode, but a friend does nothing but complain about Xcode, so thankfully they're not going to push it... and also I don't plan to get a Mac unless encouraged at gunpoint.

0.7
Compiling your first program
Hilarious title. But they say we usually start by creating a new project. A project is a container that holds all of your source code files, images, data files, etc, that are needed to produce an executable/library. Projects also save various IDE, compiler, and linker settings, and remembers where you left off.
Each project corresponds to one program. When you're ready to create a second program, you need a new project, or can overwrite a project if you don't want to keep it. Project files are generally IDE-specific.

Console projects are all we'll do in these tutorials.

Many IDEs will automatically add projects to a workspace or solution, with the term varying by IDE. This is a container that can hold one or more projects.
This tutorial nonetheless recommends a separate solution or workspace for each program, especially while learning.

While going over the Hello World program, the tutorial mentions precompiled headers.
These can improve compilation speed by avoiding some redundant compilation that tends to occur in larger projects. However, these also require extra work to use, and make no difference to smaller projects like these tutorials.

In my case, helloThere.cpp is included just to say I adhered to the tutorials like I know I should. However, rather than following IDE steps, ctrl shift B in VSCode will build without running to mimic their steps.

And funnily enough, they give a VS Code section after I already assumed they were focusing on Visual Studio. Dang.
They basically said to open a folder (which I'd already done) and create hello world, but they also... seemed to indicate that this folder was a project.
What goes on behind the scenes to make anything that could be considered a project file? Some VSCode wizard could really help me here...

Also, differences between compile, build, rebuild, clean, and run/start in IDE:
Build compiles all modified code files in the project, then links the object files into an executable. If no code files have been modified since the last build, this option does nothing.
Clean removes all cached objects and executables so the next time the project builds, all files will be recompiled and a new exe is produced.
Rebuild does clean, then build.
Compile recompiles a single code file. This option doesn't invoke the linker or produce an exe.
Run/start executes the executable from a prior build. Some IDEs (VS, for example) will invoke a build before doing a run to avoid missing the latest version's behavior.

0.8
Common problems
Reading this section, but after a quick skim, probably not taking notes when I re-read in depth.
Scratch that!
The C++ standard requires that all cpp source files end in a newline.

0.9
Configuring compiler: Build configurations
A build configuration (also called build target) is a collection of project settings that determines how the IDE builds the project. This typically includes executable name, directories the IDE will look in for other code and libraries, whether to keep debug info, and compiler optimization.
These settings should usually be default unless you have a good reason.
Debug config is designed to help debug, and is generally used when writing programs. This turns off optimizations and includes debugging info. Programs are slower and larger, but much easier to debug this way.
Release configuration is for public release, primarily. Optimized for size and speed, doesn't contain extra debug info.

Visual Studio also creates separate build config for different platforms, e.g. x86 (32 bit) and x64 (64 bit) platforms.

How to set this stuff?
Well, when you first ran the program in VSCode, a new file called tasks.json was created in the .vscode folder in the explorer pane.
Find args there and locate the line ${file} in that section.
Above that line, add a new line containing the following command (one per line) when debugging:
"-ggdb"
Above the file line, add new lines with the following for release builds:
"-02"
"-DNDEBUG"

0.10 - Configuring your compiler: Compiler extensions
C++ standard defines rules about how programs should behave in certain circumstances, and compilers usually follow these rules. However, many compilers implement their own changes. These are called compiler extensions.
Using a compiler extension allows you to write programs that aren't compatible with the C++ standard, but these programs usually won't compile on other compilers without these extensions. Or they'll run, but do so incorrectly.
Compiler extensions are often enabled by default, which sucks when you don't know.
Best practice: Disable compiler extensions by default to ensure programs and practices remain compliant with C++ standards.

To disable compiler extensions on VSCode, we open tasks.json, find "args", locate "${file}", and add "-pedantic-errors" above it.

Additionally, the tutorial recommended File>Preferences>Settings - insert final newline in both Workspace Settings and User Settings (check the box in both tabs).

Note that these settings are on a per-project basis; you need to set them every time you make a new project, or create a template project with those settings and create new projects off of that.

TODO: Figure out how to make a template project for VSCode, or how to change the default tasks.json file

0.11
Configuring your compiler: Warning and error levels
If you really screw up and violate the language rules, the compiler will emit an error during compilation, providing a line number containing the error and some text about expectation vs finding. The actual error may be elsewhere, but still, fix it and try again.
In other cases, warnings happen because the compiler thinks it sees an error, but isn't sure. Warnings don't halt compilation, but do notify the programmer that something seems incorrect.

Best practice: Pretend warnings are errors and fix them as you encouhnter them; otherwise, serious warnings may be lost amongst non-serious warnings.

In most cases, warnings can be resolved by fixing the issue or rewriting the line of code to not generate the warning.
In rare cases, you have to tell the compiler to just shut up, which is not something C++ does for you, but is instead something compilers allow you to do.

By default, most compilers only warn about obvious issues. However, you can request your compiler be more proactive about producing warnings.

Best practice: Turn warning levels up to maximum to identify possible issues.

We do this in VSCode by adding the following to tasks.json in the usual place:
                "-Wall",
                "-Weffc++",
                "-Wextra",
                "-Wconversion",
                "-Wsign-conversion",

You can, and allegedly should, also tell your compiler to treat warnings as errors (halt compilation if it finds warnings).
For this, in tasks.json, we add:
"-Werror"

0.12
Configuring your compiler: Choosing a language standard
Generally, compilers pick a standard to default to, but it's not actually the most recent by default. Many default to C++14, which is missing some stuff.
Finalized language standards are named after their year of release, but there are code names sometimes.
c++1x = C++11
c++1y = C++14
c++1z = C++17
c++2a = C++20
c++2b = C++23

This is cryptic and annoying, and hopefully won't be something I have to memorize?

It's somewhat common to choose a language standard that's a version or two back from the latest, e.g. C++17 or C++14 right now for me.
This is usually supposed to make sure compilers don't have issues, and make sure best practices for newer features are well understood.

For learning, there's little downside to choosing the latest standard.

Thankfully, for VSCode, the compiler flags for choosing a standard are fairly straightforward.
"-std=c++20" enables C++20, and the rest are pretty intuitive as well.
This flag, of course, goes in tasks.json in the args section, above that file block.

So, that's about it for chapter 0!
But one last thing. C++ language standards are described by a standards document, which is a formal technical document for rules and reqs of a given standard.
This thing is written for compiler writers, not for learning the language. People will occasionally quote the standards document to explain how things work.
But this dry, dense thingy is also not even free. You'd have to get a draft close to publication time.
Also note that compilers don't always have complete support for new language features, so don't expect C++23 to work right off the bat next year.

