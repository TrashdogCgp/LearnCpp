17_10
C-style strings

We've defined strings as a collection of sequential characters, and introduced C-style string literals.

C-style strings are just c-style arrays whose element type is char or const char.
While c-style string literals are fine to use in code, c-style string objects have fallen out of favor in modern C++ because they're hard to use and dangerous.
std::string and std::string_view are the modern replacements.

Defining c-style strings
To define a c-style string variable, simply declare a c-style array of char or const char/constexpr char.
Remember that we need an extra character for the implicit null terminator.
It's recommended to initialize by omitting the array length and letting the compiler calculate the length. This eliminates the risk of forgetting to include an extra element to hold the null terminator.

C-style strings will decay.
C-style arrays decay into a pointer in most circumstances. Since c-style strings are c-style arrays, they will decay.
And when a c-style string decays into a pointer, the length of the string (encoded in the type info) is lost.

The loss of length is why c-style strings have a null terminator. The length of the string can be (inefficiently) regenerated by counting the number of elements between the start of the string and the null terminator. Alternatively, the string can be traversed by iterating from the start until we hit the null terminator.

Outputting a c-style string
When outputting a c-style string, std::cout outputs characters until it encounters the null terminator. The null terminator marks the end of the string, so that decayed string (which have their info lost) can still be printed.

If you tr to print a string that doesn't have a null terminator (e.g. because the null terminator was overwritten), the result will be undefined behavior.
The most likely outcome in this case will be that all the characters in the string are printed, and it'll just keep printing everything in adjacent memory slows as characters until it happens to reach a byte containing 0, null terminator in char.

Inputting c-style strings
When accepting input, the solution has usually been to declare an array larger than we ever expect to read.
Prior to C++20, nothing stopped the user from entering more than 254 characters for a 255 character char array, and in that case, the user's input overflows and we get undefined behavior.

In C++20, the >> operator was changed so it only works for inputting non-decayed c-style strings, which allows the >> operator to only extract as many characters as the c-style string's length will allow, preventing overflow.
This also means you no longer use the >> operator to input to decayed c-style strings.

The recommended way to read c-style strings using std::cin is:
    #include <iostream>
    #include <iterator> // for std::size

    int main()
    {
        char rolls[255] {}; // declare array large enough to hold 254 characters + null terminator
        std::cout << "Enter your rolls: ";
        std::cin.getline(rolls, std::size(rolls));
        std::cout << "You entered: " << rolls << '\n';
        return 0;
    }

cin.getline() will read up to 254 characters into rolls.
Any excess characters will be discarded.
Because getline() takes a length, we can provide the maximum number of characters to accept.
With a non-decayed array, this is easy because we can use std::size().
With a decayed array, it's harder and if we provide the wrong length, we may have malfunction or security issues.

In modern C++, it's safer to use std::string, since it automatically adjusts to hold as many characters as needed.

Modifying c-style strings
C-style strings follow the same rules as c-style arrays. You can initialize a string upon creation, but can't assign values to it via the assignment operator after that.

This makes c-style strings a bit awkward to use.
Since c-style strings are arrays, you can use the [] operator to change individual characters in the string.
e.g.
    char str[]{ "string" };
    str[1] = 'p';

Getting the length of a c-style string
Since c-style strings are c-style arrays, you can use std::size() or std::ssize() to get the length of the string as an array.
Two caveats:
    This doesn't work on decayed strings
    This returns the actual length of the c-style array, not the length of the string
    
An alternative is to use strlen(), which lives in <cstring>. strlen() will work on decayed arrays, and returns the length of the string being held, excluding the null terminator.
e.g.
    char str[255]{ "string" }; // 6 characters + null terminator
    std::cout << "length = " << std::strlen(str) << '\n'; // prints length = 6

    char *ptr { str };
    std::cout << "length = " << std::strlen(ptr) << '\n';   // prints length = 6

std::strlen() is slow, since it traverses the whole array and counts characters until it hits the null terminator.

Other c-style string manipulating functions
    strlen() -- returns the length of a C-style string
    strcpy(), strncpy(), strcpy_s() -- overwrites one C-style string with another
    strcat(), strncat() -- Appends one C-style string to the end of another
    strcmp(), strncmp() -- Compares two C-style strings (returns 0 if equal)
These are part of the <cstring> header.

Avoid non-const c-style string objects
Unless you have a compelling, specific reason to use non-const c-style strings, they're best avoided, since they're awkward to work with and are prone to overruns, which will cause undefined behavior.
If you need to work with c-style strings or fixed buffer sizes (e.g. for memory-limited devices), use a 3rd party fixed-length string library designed for the purpose.

Best practice: Avoid non-const c-style string objects in favor of std::string

Quiz

1. Write a function to print a c-style string character by character.
Use a pointer and pointer arithmetic to step through each character of the string and print that character.
Test using hello world as a string.
see Ch17_10_1.cpp

2. Repeat quiz 1, but print the string backwards.
added to Ch17_10_1.cpp














