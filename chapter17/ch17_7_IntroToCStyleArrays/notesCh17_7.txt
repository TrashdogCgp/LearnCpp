17_7
Introduction to c-style arrays

C-style arrays were inherited from the C language.
They're built into the core language of C++ (unlike the rest of the array types, which are standard library container classes).
This means we don't need to #include a header file to use them.

It's worth noting that because c-style arrays are the only array type natively supported by the language, the standard library array container types (std::array and std::vector) are typically implemented using a c-style array.

Declaring a c-style array
C-style arrays have their own special declaration syntax.
In a c-style array declaration, we use square brackets [] to tell the  compiler that a declared object is a c-style array.
In the square brackets, we can optionally provide the length of the array, which is an integral value of type std::size_t that tells the compiler how many elements are in the array.

e.g.
    int testScore[30] {};      // Defines a C-style array named testScore that contains 30 value-initialized int elements (no include required)

The length of a c-style array must be at least 1.
The compiler will error if the array length is zero, negative, or a non-integral value.

The array length of a c-style array must be a constant expression
Just like std::array, when declaring a c-style array, the length of the array must be a constant expression (type std::size_t, though this doesn't typically matter).

Some compilers may allow creation of arrays with non-constexpr lengths, for compatibility with a C99 feature called variable-length arrays (VLAs).
Variable-length arrays are not valid C++, and should not be used in C++ programs. If your compiler allows these arrays, you probably forgot to disable compiler extensions.

Subscripting a c-style array
Just like with a std::array, c-style arrays can be indexed using the subscript operator [].
e.g.
    int arr[5]; // define an array of 5 int values
    arr[1] = 7; // use subscript operator to index array element 1

Unlike the standard library container classes (use unsigned indices only), the index of a c-style array can be either a signed or unsigned integer, or an unscoped enumeration. This means c-style arrays are not subject to all of the sign conversion indexing issues of the standard library container classes.
C-style arrays will accept signed or unsigned indexes (or unscoped enumerations).

operator[] does not do bounds checking, and passing an out-of-bounds index will result in undefined behavior.

Aggregate initialization of C-style arrays
Just like std::array, C-style arrays are aggregated, meaning they can be initialized using aggregate initialization.
Aggregate initialization allows us to directly initialize the members of aggregates. To do this, we provide an initializer list, which is a brace-enclosed list of comma-separated initialization values.
e.g.
    int fibonnaci[6] = { 0, 1, 1, 2, 3, 5 }; // copy-list initialization using braced list
Each of these initialization forms initializes the array members in sequence, starting with element 0.

If you don't provide an initializer for a c-style array, the elements will be default initialized. In most cases, this results in the elements being left uninitialized.
Since we generally want our elements to be initialized, c-style arrays should be value-initialized (empty braces) when defined with no initializers.

If more initializers are provided than the defined array length, the compiler will error.
If fewer initializers are provided than the defined array length, the remaining elements without initializers are value initialized.

One downside of C-style arrays is that the element type must be explicitly specified. CTAD doesn't work because c-style arrays aren't class templates.
And using auto to deduce the element type of an array from the list of initializers doesn't work either.

Omitted length
The prior declaration syntax has a significant redundancy.
We explicitly tell the compiler the array has a length, then also initialize it with a number of elements.
We can omit the length in the array definition and let the compiler deduce the length of the array from the number of initializers.
e.g.
    const int prime2[] { 2, 3, 5, 7, 11 };  // prime2 deduced by compiler to have length 5

This only works when initializers are explicitly provided for all array members.
see misuse example:
    int bad[] {}; // error: the compiler will deduce this to be a zero-length array, which is disallowed!

Best practice: Prefer omitting the length of a c-style array when explicitly initializing every array element with a value.

Const and constexpr c-style arrays
Just like std::array, c-style arrays can be const or constexpr.
Just like other const variables, const arrays must be initialized, and the value of the elements cannot be changed afterward.
e.g.
    constexpr int squares[5] { 1, 4, 9, 16, 25 }; // an array of constexpr int

sizeof for a c-style array
The sizeof() operator can get the size of an object or type in bytes.
Applied to a c-style array, sizeof() returns the number of bytes used by the entire array.
Assuming 4 byte ints, the following prints 20:
    const int prime[] { 2, 3, 5, 7, 11 }; // the compiler will deduce prime to have length 5
    std::cout << sizeof(prime); // prints 20 (assuming 4 byte ints)

Note that there is no overhead; an array object contains its elements and nothing more.

Getting the length of a c-style array
In C++17, we can use std::size(), defined in the <iterator> header, which returns the array length as an unsigned integral value of type std::size_t.
In C++20, we can use std::ssize() to return the array length as a signed integral value, probably of type std::ptrdiff_t.
e.g.
    const int prime[] { 2, 3, 5, 7, 11 };   // the compiler will deduce prime to have length 5

    std::cout << std::size(prime) << '\n';  // C++17, returns unsigned integral value 5
    std::cout << std::ssize(prime) << '\n'; // C++20, returns signed integral value 5

Getting the length of a C-style array, C++14 or older
Prior to C++17, there was no standard library function to get the length of a c-style array.
In C++11 or C++14, we can do the following:
    template <typename T, std::size_t N>
    constexpr std::size_t length(const T(&)[N]) noexcept
    {
        return N;
    }

This uses a function template that takes a c-style array by reference, then returns the non-type template parameter representing the array's length.

In much older codebases, you may see the length of a c-style array determined by dividing the size of the entire array by the size of an array element.
e.g.
    std::cout << "The array has: " << sizeof(array) / sizeof(array[0]) << " elements\n";

This can fail quite easily when passed a decayed array. This leaves the program unexpectedly broken.
C++'s std::size() and length() function template shown above will both cause compilation errors in the case of a decayed array, so they're safe to use.

Quiz

1.
Convert the following std::array definition to an equivalent constexpr C-style array definition:

constexpr std::array<int, 3> a{}; // allocate 3 ints

Answer:
constexpr int a[3]{};

2. What three things are wrong with the following program?
    #include <iostream>

    int main()
    {
        int length{ 5 };
        const int arr[length] { 9, 7, 5, 3, 1 };

        std::cout << arr[length];
        arr[0] = 4;

        return 0;
    }

i) arr is being initialized with a non-constexpr length.
ii) We're trying to access the 6th element (index 5) of a 5-member array.
iii) We're trying to assign a new value to an element of a const array.

3.
A “perfect square” is a natural number whose square root is an integer. We can make perfect squares by multiplying a natural number (including zero) by itself. The first 4 perfect squares are: 0, 1, 4, 9.

Use a global constexpr C-style array to hold the perfect squares between 0 and 9 (inclusive). Repeatedly ask the user to enter a single digit integer, or -1 to quit. Print whether the digit the user entered is a perfect square.

see ch17_7_3.cpp








